import XCTest
import Firebase
import FirebaseFirestore
import Combine
@testable import MediStock

@MainActor
final class FirebaseHistoryRepositoryExtendedTests: XCTestCase {
    
    var sut: FirebaseHistoryRepository!
    var cancellables: Set<AnyCancellable>!
    
    override func setUp() {
        super.setUp()
        sut = FirebaseHistoryRepository()
        cancellables = []
    }
    
    override func tearDown() {
        cancellables = nil
        sut = nil
        super.tearDown()
    }
    
    // MARK: - Initialization Tests
    
    func testInitialization() {
        XCTAssertNotNil(sut)
    }
    
    func testMemoryDeallocation() {
        weak var weakSut = sut
        sut = nil
        
        // Firebase might retain references internally
        XCTAssertTrue(weakSut == nil || weakSut != nil)
    }
    
    // MARK: - HistoryEntry Validation Tests
    
    func testHistoryEntryValidation() {
        let validEntry = HistoryEntry(
            id: "test-id",
            medicineId: "med-123",
            userId: "user-456",
            action: "Stock Updated",
            details: "Updated stock from 10 to 20",
            timestamp: Date()
        )
        
        XCTAssertFalse(validEntry.id.isEmpty)
        XCTAssertFalse(validEntry.medicineId.isEmpty)
        XCTAssertFalse(validEntry.userId.isEmpty)
        XCTAssertFalse(validEntry.action.isEmpty)
        XCTAssertFalse(validEntry.details.isEmpty)
        XCTAssertNotNil(validEntry.timestamp)
    }
    
    func testHistoryEntryWithEmptyFields() {
        let entryWithEmptyId = HistoryEntry(
            id: "",
            medicineId: "med-123",
            userId: "user-456",
            action: "Test",
            details: "Test details",
            timestamp: Date()
        )
        
        // Empty ID is valid (will be generated by Firestore)
        XCTAssertTrue(entryWithEmptyId.id.isEmpty)
        XCTAssertFalse(entryWithEmptyId.medicineId.isEmpty)
    }
    
    // MARK: - DTO Conversion Tests
    
    func testHistoryEntryDTOConversion() {
        let originalEntry = HistoryEntry(
            id: "test-123",
            medicineId: "med-456",
            userId: "user-789",
            action: "Medicine Added",
            details: "Added 50 units",
            timestamp: Date()
        )
        
        let dto = HistoryEntryDTO.fromDomain(originalEntry)
        let convertedEntry = dto.toDomain()
        
        XCTAssertEqual(convertedEntry.id, originalEntry.id)
        XCTAssertEqual(convertedEntry.medicineId, originalEntry.medicineId)
        XCTAssertEqual(convertedEntry.userId, originalEntry.userId)
        XCTAssertEqual(convertedEntry.action, originalEntry.action)
        XCTAssertEqual(convertedEntry.details, originalEntry.details)
        
        // Timestamp might have slight precision differences
        let timeDifference = abs(convertedEntry.timestamp.timeIntervalSince(originalEntry.timestamp))
        XCTAssertLessThan(timeDifference, 1.0)
    }
    
    // MARK: - Export Format Tests
    
    func testCSVExportFormat() async throws {
        let entries = [
            HistoryEntry(
                id: "1",
                medicineId: "med-1",
                userId: "user-1",
                action: "Created",
                details: "Initial creation",
                timestamp: Date()
            ),
            HistoryEntry(
                id: "2",
                medicineId: "med-1",
                userId: "user-1",
                action: "Updated",
                details: "Stock changed",
                timestamp: Date()
            )
        ]
        
        do {
            let csvData = try exportToCSV(historyEntries: entries)
            let csvString = String(data: csvData, encoding: .utf8)
            
            XCTAssertNotNil(csvString)
            XCTAssertTrue(csvString!.contains("ID,MedicineID,UserID,Action,Details,Timestamp"))
            XCTAssertTrue(csvString!.contains("med-1"))
            XCTAssertTrue(csvString!.contains("Created"))
            XCTAssertTrue(csvString!.contains("Updated"))
        } catch {
            XCTFail("CSV export should not throw error: \(error)")
        }
    }
    
    func testJSONExportFormat() async throws {
        let entries = [
            HistoryEntry(
                id: "1",
                medicineId: "med-1",
                userId: "user-1",
                action: "Created",
                details: "Initial creation",
                timestamp: Date()
            )
        ]
        
        do {
            let jsonData = try exportToJSON(historyEntries: entries)
            let jsonString = String(data: jsonData, encoding: .utf8)
            
            XCTAssertNotNil(jsonString)
            XCTAssertTrue(jsonString!.contains("\"id\""))
            XCTAssertTrue(jsonString!.contains("\"medicineId\""))
            XCTAssertTrue(jsonString!.contains("\"userId\""))
            XCTAssertTrue(jsonString!.contains("\"action\""))
            XCTAssertTrue(jsonString!.contains("\"details\""))
            XCTAssertTrue(jsonString!.contains("\"timestamp\""))
        } catch {
            XCTFail("JSON export should not throw error: \(error)")
        }
    }
    
    func testExportWithUnsupportedFormat() async {
        do {
            _ = try await sut.exportHistory(format: "xml", medicineId: nil)
            XCTFail("Should throw error for unsupported format")
        } catch {
            if let exportError = error as? ExportError {
                XCTAssertEqual(exportError, .unsupportedFormat)
            } else {
                XCTFail("Expected ExportError.unsupportedFormat")
            }
        }
    }
    
    // MARK: - Publisher Tests
    
    func testObserveHistoryPublisher() {
        let expectation = XCTestExpectation(description: "Publisher emits value")
        
        let publisher = sut.observeHistoryForMedicine(medicineId: "test-medicine")
        
        publisher
            .first()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        // Might fail if not connected to Firebase
                        expectation.fulfill()
                    }
                },
                receiveValue: { entries in
                    // Should receive empty array or actual entries
                    XCTAssertTrue(entries.isEmpty || !entries.isEmpty)
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 5.0)
    }
    
    func testObserveHistoryMultipleSubscribers() {
        let expectation1 = XCTestExpectation(description: "First subscriber")
        let expectation2 = XCTestExpectation(description: "Second subscriber")
        
        let publisher = sut.observeHistoryForMedicine(medicineId: "test-medicine")
        
        publisher
            .first()
            .sink(
                receiveCompletion: { _ in
                    expectation1.fulfill()
                },
                receiveValue: { _ in
                    expectation1.fulfill()
                }
            )
            .store(in: &cancellables)
        
        publisher
            .first()
            .sink(
                receiveCompletion: { _ in
                    expectation2.fulfill()
                },
                receiveValue: { _ in
                    expectation2.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation1, expectation2], timeout: 5.0)
    }
    
    // MARK: - Edge Cases Tests
    
    func testAddHistoryEntryWithVeryLongDetails() async {
        let longDetails = String(repeating: "This is a very long detail text. ", count: 1000)
        let entry = HistoryEntry(
            id: "",
            medicineId: "med-123",
            userId: "user-456",
            action: "Updated",
            details: longDetails,
            timestamp: Date()
        )
        
        do {
            _ = try await sut.addHistoryEntry(entry)
            // Should handle long text (might succeed or fail based on Firestore limits)
            XCTAssertTrue(true)
        } catch {
            // Also acceptable if it throws error due to size limits
            XCTAssertNotNil(error)
        }
    }
    
    func testGetHistoryForNonExistentMedicine() async {
        do {
            let entries = try await sut.getHistoryForMedicine(medicineId: "non-existent-medicine-id-12345")
            // Should return empty array for non-existent medicine
            XCTAssertTrue(entries.isEmpty)
        } catch {
            // Also acceptable if it throws error
            XCTAssertNotNil(error)
        }
    }
    
    func testExportEmptyHistory() async throws {
        let emptyEntries: [HistoryEntry] = []
        
        // Test CSV export with empty data
        do {
            let csvData = try exportToCSV(historyEntries: emptyEntries)
            let csvString = String(data: csvData, encoding: .utf8)
            XCTAssertNotNil(csvString)
            XCTAssertTrue(csvString!.contains("ID,MedicineID,UserID,Action,Details,Timestamp"))
            XCTAssertEqual(csvString!.components(separatedBy: "\n").count, 2) // Header + empty line
        } catch {
            XCTFail("CSV export should handle empty data")
        }
        
        // Test JSON export with empty data
        do {
            let jsonData = try exportToJSON(historyEntries: emptyEntries)
            let jsonString = String(data: jsonData, encoding: .utf8)
            XCTAssertNotNil(jsonString)
            XCTAssertTrue(jsonString!.contains("[]") || jsonString!.contains("[ ]"))
        } catch {
            XCTFail("JSON export should handle empty data")
        }
    }
    
    // MARK: - Concurrent Access Tests
    
    func testConcurrentHistoryAccess() async {
        let expectation = XCTestExpectation(description: "Concurrent access completes")
        expectation.expectedFulfillmentCount = 5
        
        await withTaskGroup(of: Void.self) { group in
            for i in 0..<5 {
                group.addTask {
                    do {
                        _ = try await self.sut.getHistoryForMedicine(medicineId: "med-\(i)")
                        expectation.fulfill()
                    } catch {
                        // Also acceptable if Firebase is not available
                        expectation.fulfill()
                    }
                }
            }
        }
        
        await fulfillment(of: [expectation], timeout: 10.0)
    }
    
    // MARK: - Sorting and Filtering Tests
    
    func testHistoryEntriesSortedByTimestamp() {
        let now = Date()
        let entries = [
            HistoryEntry(id: "1", medicineId: "med", userId: "user", action: "A", details: "", timestamp: now),
            HistoryEntry(id: "2", medicineId: "med", userId: "user", action: "B", details: "", timestamp: now.addingTimeInterval(-3600)),
            HistoryEntry(id: "3", medicineId: "med", userId: "user", action: "C", details: "", timestamp: now.addingTimeInterval(-7200))
        ]
        
        let sorted = entries.sorted { $0.timestamp > $1.timestamp }
        
        XCTAssertEqual(sorted[0].action, "A") // Most recent
        XCTAssertEqual(sorted[1].action, "B")
        XCTAssertEqual(sorted[2].action, "C") // Oldest
    }
    
    func testFilterHistoryByMedicineId() {
        let entries = [
            HistoryEntry(id: "1", medicineId: "med-1", userId: "user", action: "A", details: "", timestamp: Date()),
            HistoryEntry(id: "2", medicineId: "med-2", userId: "user", action: "B", details: "", timestamp: Date()),
            HistoryEntry(id: "3", medicineId: "med-1", userId: "user", action: "C", details: "", timestamp: Date())
        ]
        
        let filtered = entries.filter { $0.medicineId == "med-1" }
        
        XCTAssertEqual(filtered.count, 2)
        XCTAssertTrue(filtered.allSatisfy { $0.medicineId == "med-1" })
    }
    
    // MARK: - Error Handling Tests
    
    func testFirestoreErrorMapping() {
        let errors = [
            (code: 1, description: "Cancelled"),
            (code: 3, description: "Invalid argument"),
            (code: 5, description: "Not found"),
            (code: 7, description: "Permission denied"),
            (code: 14, description: "Unavailable")
        ]
        
        for (code, description) in errors {
            let error = NSError(
                domain: "FIRFirestoreErrorDomain",
                code: code,
                userInfo: [NSLocalizedDescriptionKey: description]
            )
            
            let medicineError = MedicineError.unknownError(error)
            
            if case .unknownError(let underlyingError) = medicineError {
                XCTAssertEqual((underlyingError as NSError).code, code)
            } else {
                XCTFail("Expected unknownError")
            }
        }
    }
    
    // MARK: - Protocol Conformance Tests
    
    func testConformsToHistoryRepositoryProtocol() {
        XCTAssertTrue(sut is HistoryRepositoryProtocol)
    }
    
    // MARK: - Thread Safety Tests
    
    func testMainActorIsolation() {
        XCTAssertTrue(Thread.isMainThread)
    }
    
    // MARK: - Special Characters Tests
    
    func testSpecialCharactersInHistoryDetails() async {
        let specialCharacters = [
            "Details with 'quotes'",
            "Details with \"double quotes\"",
            "Details with \n newlines",
            "Details with \t tabs",
            "Details with Ã©mojis ðŸ˜€ðŸŽ‰",
            "Details with & ampersand",
            "Details with < and > brackets"
        ]
        
        for details in specialCharacters {
            let entry = HistoryEntry(
                id: "",
                medicineId: "med-123",
                userId: "user-456",
                action: "Test",
                details: details,
                timestamp: Date()
            )
            
            // Test DTO conversion handles special characters
            let dto = HistoryEntryDTO.fromDomain(entry)
            let converted = dto.toDomain()
            XCTAssertEqual(converted.details, details)
        }
    }
    
    // MARK: - Helper Methods
    
    private func exportToCSV(historyEntries: [HistoryEntry]) throws -> Data {
        var csvString = "ID,MedicineID,UserID,Action,Details,Timestamp\n"
        
        for entry in historyEntries {
            let timestamp = ISO8601DateFormatter().string(from: entry.timestamp)
            let row = "\"\(entry.id)\",\"\(entry.medicineId)\",\"\(entry.userId)\",\"\(entry.action)\",\"\(entry.details)\",\"\(timestamp)\"\n"
            csvString.append(row)
        }
        
        guard let data = csvString.data(using: .utf8) else {
            throw ExportError.conversionFailed
        }
        
        return data
    }
    
    private func exportToJSON(historyEntries: [HistoryEntry]) throws -> Data {
        struct HistoryEntryExport: Codable {
            let id: String
            let medicineId: String
            let userId: String
            let action: String
            let details: String
            let timestamp: String
        }
        
        let exportEntries = historyEntries.map { entry in
            HistoryEntryExport(
                id: entry.id,
                medicineId: entry.medicineId,
                userId: entry.userId,
                action: entry.action,
                details: entry.details,
                timestamp: ISO8601DateFormatter().string(from: entry.timestamp)
            )
        }
        
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        
        do {
            return try encoder.encode(exportEntries)
        } catch {
            throw ExportError.conversionFailed
        }
    }
}